# Generated from arm_assembly.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,41,126,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,3,2,42,8,2,
        1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,1,4,1,5,1,5,
        1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,90,8,
        8,1,8,1,8,1,9,1,9,1,9,1,9,3,9,98,8,9,1,10,1,10,3,10,102,8,10,1,11,
        1,11,1,11,1,11,1,11,3,11,109,8,11,1,12,1,12,1,12,1,12,1,12,3,12,
        116,8,12,1,13,1,13,1,13,1,13,3,13,122,8,13,1,14,1,14,1,14,0,0,15,
        0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,0,6,1,0,1,16,1,0,35,36,1,
        0,17,21,1,0,22,23,1,0,28,32,1,0,26,27,121,0,30,1,0,0,0,2,32,1,0,
        0,0,4,41,1,0,0,0,6,43,1,0,0,0,8,51,1,0,0,0,10,57,1,0,0,0,12,63,1,
        0,0,0,14,71,1,0,0,0,16,81,1,0,0,0,18,93,1,0,0,0,20,101,1,0,0,0,22,
        108,1,0,0,0,24,115,1,0,0,0,26,117,1,0,0,0,28,123,1,0,0,0,30,31,7,
        0,0,0,31,1,1,0,0,0,32,33,5,34,0,0,33,34,7,1,0,0,34,3,1,0,0,0,35,
        42,3,6,3,0,36,42,3,8,4,0,37,42,3,10,5,0,38,42,3,12,6,0,39,42,3,14,
        7,0,40,42,3,16,8,0,41,35,1,0,0,0,41,36,1,0,0,0,41,37,1,0,0,0,41,
        38,1,0,0,0,41,39,1,0,0,0,41,40,1,0,0,0,42,5,1,0,0,0,43,44,7,2,0,
        0,44,45,5,39,0,0,45,46,3,0,0,0,46,47,5,40,0,0,47,48,3,0,0,0,48,49,
        5,40,0,0,49,50,3,20,10,0,50,7,1,0,0,0,51,52,7,3,0,0,52,53,5,39,0,
        0,53,54,3,0,0,0,54,55,5,40,0,0,55,56,3,20,10,0,56,9,1,0,0,0,57,58,
        7,4,0,0,58,59,5,39,0,0,59,60,3,0,0,0,60,61,5,40,0,0,61,62,3,18,9,
        0,62,11,1,0,0,0,63,64,5,24,0,0,64,65,5,39,0,0,65,66,3,0,0,0,66,67,
        5,40,0,0,67,68,3,0,0,0,68,69,5,40,0,0,69,70,3,0,0,0,70,13,1,0,0,
        0,71,72,5,25,0,0,72,73,5,39,0,0,73,74,3,0,0,0,74,75,5,40,0,0,75,
        76,3,0,0,0,76,77,5,40,0,0,77,78,3,0,0,0,78,79,5,40,0,0,79,80,3,0,
        0,0,80,15,1,0,0,0,81,82,7,5,0,0,82,83,5,39,0,0,83,84,3,0,0,0,84,
        85,5,40,0,0,85,86,5,37,0,0,86,89,3,0,0,0,87,88,5,40,0,0,88,90,3,
        20,10,0,89,87,1,0,0,0,89,90,1,0,0,0,90,91,1,0,0,0,91,92,5,38,0,0,
        92,17,1,0,0,0,93,94,3,0,0,0,94,97,5,40,0,0,95,98,3,2,1,0,96,98,3,
        0,0,0,97,95,1,0,0,0,97,96,1,0,0,0,98,19,1,0,0,0,99,102,3,22,11,0,
        100,102,3,24,12,0,101,99,1,0,0,0,101,100,1,0,0,0,102,21,1,0,0,0,
        103,109,3,2,1,0,104,105,3,2,1,0,105,106,5,40,0,0,106,107,7,1,0,0,
        107,109,1,0,0,0,108,103,1,0,0,0,108,104,1,0,0,0,109,23,1,0,0,0,110,
        116,3,0,0,0,111,112,3,0,0,0,112,113,5,40,0,0,113,114,3,26,13,0,114,
        116,1,0,0,0,115,110,1,0,0,0,115,111,1,0,0,0,116,25,1,0,0,0,117,118,
        3,28,14,0,118,121,5,39,0,0,119,122,3,22,11,0,120,122,3,0,0,0,121,
        119,1,0,0,0,121,120,1,0,0,0,122,27,1,0,0,0,123,124,7,4,0,0,124,29,
        1,0,0,0,7,41,89,97,101,108,115,121
    ]

class arm_assemblyParser ( Parser ):

    grammarFileName = "arm_assembly.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'#'", "<INVALID>", "<INVALID>", 
                     "'['", "']'" ]

    symbolicNames = [ "<INVALID>", "R0", "R1", "R2", "R3", "R4", "R5", "R6", 
                      "R7", "R8", "R9", "R10", "R11", "R12", "R13", "R14", 
                      "R15", "AND", "EOR", "SUB", "ADD", "ORR", "MOV", "MVN", 
                      "MUL", "MLA", "LDR", "STR", "LSL", "LSR", "ASR", "ROR", 
                      "RRX", "LABEL", "HASH", "HEX", "NUMBER", "LBRACKET", 
                      "RBRACKET", "SPACE", "COMMA", "WS" ]

    RULE_reg = 0
    RULE_immediate = 1
    RULE_instruction = 2
    RULE_dp_instruction = 3
    RULE_mov_instruction = 4
    RULE_shift_instruction = 5
    RULE_mul_instruction = 6
    RULE_mla_instruction = 7
    RULE_ls_instruction = 8
    RULE_shift_operand = 9
    RULE_operand2 = 10
    RULE_immediate_format = 11
    RULE_register_format = 12
    RULE_shift_op = 13
    RULE_shift_type = 14

    ruleNames =  [ "reg", "immediate", "instruction", "dp_instruction", 
                   "mov_instruction", "shift_instruction", "mul_instruction", 
                   "mla_instruction", "ls_instruction", "shift_operand", 
                   "operand2", "immediate_format", "register_format", "shift_op", 
                   "shift_type" ]

    EOF = Token.EOF
    R0=1
    R1=2
    R2=3
    R3=4
    R4=5
    R5=6
    R6=7
    R7=8
    R8=9
    R9=10
    R10=11
    R11=12
    R12=13
    R13=14
    R14=15
    R15=16
    AND=17
    EOR=18
    SUB=19
    ADD=20
    ORR=21
    MOV=22
    MVN=23
    MUL=24
    MLA=25
    LDR=26
    STR=27
    LSL=28
    LSR=29
    ASR=30
    ROR=31
    RRX=32
    LABEL=33
    HASH=34
    HEX=35
    NUMBER=36
    LBRACKET=37
    RBRACKET=38
    SPACE=39
    COMMA=40
    WS=41

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def R0(self):
            return self.getToken(arm_assemblyParser.R0, 0)

        def R1(self):
            return self.getToken(arm_assemblyParser.R1, 0)

        def R2(self):
            return self.getToken(arm_assemblyParser.R2, 0)

        def R3(self):
            return self.getToken(arm_assemblyParser.R3, 0)

        def R4(self):
            return self.getToken(arm_assemblyParser.R4, 0)

        def R5(self):
            return self.getToken(arm_assemblyParser.R5, 0)

        def R6(self):
            return self.getToken(arm_assemblyParser.R6, 0)

        def R7(self):
            return self.getToken(arm_assemblyParser.R7, 0)

        def R8(self):
            return self.getToken(arm_assemblyParser.R8, 0)

        def R9(self):
            return self.getToken(arm_assemblyParser.R9, 0)

        def R10(self):
            return self.getToken(arm_assemblyParser.R10, 0)

        def R11(self):
            return self.getToken(arm_assemblyParser.R11, 0)

        def R12(self):
            return self.getToken(arm_assemblyParser.R12, 0)

        def R13(self):
            return self.getToken(arm_assemblyParser.R13, 0)

        def R14(self):
            return self.getToken(arm_assemblyParser.R14, 0)

        def R15(self):
            return self.getToken(arm_assemblyParser.R15, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg" ):
                listener.enterReg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg" ):
                listener.exitReg(self)




    def reg(self):

        localctx = arm_assemblyParser.RegContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_reg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 131070) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImmediateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASH(self):
            return self.getToken(arm_assemblyParser.HASH, 0)

        def HEX(self):
            return self.getToken(arm_assemblyParser.HEX, 0)

        def NUMBER(self):
            return self.getToken(arm_assemblyParser.NUMBER, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_immediate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImmediate" ):
                listener.enterImmediate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImmediate" ):
                listener.exitImmediate(self)




    def immediate(self):

        localctx = arm_assemblyParser.ImmediateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_immediate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.match(arm_assemblyParser.HASH)
            self.state = 33
            _la = self._input.LA(1)
            if not(_la==35 or _la==36):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dp_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Dp_instructionContext,0)


        def mov_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Mov_instructionContext,0)


        def shift_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Shift_instructionContext,0)


        def mul_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Mul_instructionContext,0)


        def mla_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Mla_instructionContext,0)


        def ls_instruction(self):
            return self.getTypedRuleContext(arm_assemblyParser.Ls_instructionContext,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)




    def instruction(self):

        localctx = arm_assemblyParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_instruction)
        try:
            self.state = 41
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17, 18, 19, 20, 21]:
                self.enterOuterAlt(localctx, 1)
                self.state = 35
                self.dp_instruction()
                pass
            elif token in [22, 23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 36
                self.mov_instruction()
                pass
            elif token in [28, 29, 30, 31, 32]:
                self.enterOuterAlt(localctx, 3)
                self.state = 37
                self.shift_instruction()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 4)
                self.state = 38
                self.mul_instruction()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 5)
                self.state = 39
                self.mla_instruction()
                pass
            elif token in [26, 27]:
                self.enterOuterAlt(localctx, 6)
                self.state = 40
                self.ls_instruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dp_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opcode = None # Token

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(arm_assemblyParser.RegContext)
            else:
                return self.getTypedRuleContext(arm_assemblyParser.RegContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(arm_assemblyParser.COMMA)
            else:
                return self.getToken(arm_assemblyParser.COMMA, i)

        def operand2(self):
            return self.getTypedRuleContext(arm_assemblyParser.Operand2Context,0)


        def ADD(self):
            return self.getToken(arm_assemblyParser.ADD, 0)

        def SUB(self):
            return self.getToken(arm_assemblyParser.SUB, 0)

        def AND(self):
            return self.getToken(arm_assemblyParser.AND, 0)

        def EOR(self):
            return self.getToken(arm_assemblyParser.EOR, 0)

        def ORR(self):
            return self.getToken(arm_assemblyParser.ORR, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_dp_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDp_instruction" ):
                listener.enterDp_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDp_instruction" ):
                listener.exitDp_instruction(self)




    def dp_instruction(self):

        localctx = arm_assemblyParser.Dp_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_dp_instruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 43
            localctx.opcode = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4063232) != 0)):
                localctx.opcode = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 44
            self.match(arm_assemblyParser.SPACE)
            self.state = 45
            self.reg()
            self.state = 46
            self.match(arm_assemblyParser.COMMA)
            self.state = 47
            self.reg()
            self.state = 48
            self.match(arm_assemblyParser.COMMA)
            self.state = 49
            self.operand2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mov_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opcode = None # Token

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self):
            return self.getTypedRuleContext(arm_assemblyParser.RegContext,0)


        def COMMA(self):
            return self.getToken(arm_assemblyParser.COMMA, 0)

        def operand2(self):
            return self.getTypedRuleContext(arm_assemblyParser.Operand2Context,0)


        def MOV(self):
            return self.getToken(arm_assemblyParser.MOV, 0)

        def MVN(self):
            return self.getToken(arm_assemblyParser.MVN, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_mov_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMov_instruction" ):
                listener.enterMov_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMov_instruction" ):
                listener.exitMov_instruction(self)




    def mov_instruction(self):

        localctx = arm_assemblyParser.Mov_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_mov_instruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            localctx.opcode = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==22 or _la==23):
                localctx.opcode = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 52
            self.match(arm_assemblyParser.SPACE)
            self.state = 53
            self.reg()
            self.state = 54
            self.match(arm_assemblyParser.COMMA)
            self.state = 55
            self.operand2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opcode = None # Token

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self):
            return self.getTypedRuleContext(arm_assemblyParser.RegContext,0)


        def COMMA(self):
            return self.getToken(arm_assemblyParser.COMMA, 0)

        def shift_operand(self):
            return self.getTypedRuleContext(arm_assemblyParser.Shift_operandContext,0)


        def LSL(self):
            return self.getToken(arm_assemblyParser.LSL, 0)

        def LSR(self):
            return self.getToken(arm_assemblyParser.LSR, 0)

        def ASR(self):
            return self.getToken(arm_assemblyParser.ASR, 0)

        def ROR(self):
            return self.getToken(arm_assemblyParser.ROR, 0)

        def RRX(self):
            return self.getToken(arm_assemblyParser.RRX, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_shift_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_instruction" ):
                listener.enterShift_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_instruction" ):
                listener.exitShift_instruction(self)




    def shift_instruction(self):

        localctx = arm_assemblyParser.Shift_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_shift_instruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            localctx.opcode = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8321499136) != 0)):
                localctx.opcode = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 58
            self.match(arm_assemblyParser.SPACE)
            self.state = 59
            self.reg()
            self.state = 60
            self.match(arm_assemblyParser.COMMA)
            self.state = 61
            self.shift_operand()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mul_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(arm_assemblyParser.MUL, 0)

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(arm_assemblyParser.RegContext)
            else:
                return self.getTypedRuleContext(arm_assemblyParser.RegContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(arm_assemblyParser.COMMA)
            else:
                return self.getToken(arm_assemblyParser.COMMA, i)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_mul_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul_instruction" ):
                listener.enterMul_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul_instruction" ):
                listener.exitMul_instruction(self)




    def mul_instruction(self):

        localctx = arm_assemblyParser.Mul_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_mul_instruction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self.match(arm_assemblyParser.MUL)
            self.state = 64
            self.match(arm_assemblyParser.SPACE)
            self.state = 65
            self.reg()
            self.state = 66
            self.match(arm_assemblyParser.COMMA)
            self.state = 67
            self.reg()
            self.state = 68
            self.match(arm_assemblyParser.COMMA)
            self.state = 69
            self.reg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mla_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MLA(self):
            return self.getToken(arm_assemblyParser.MLA, 0)

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(arm_assemblyParser.RegContext)
            else:
                return self.getTypedRuleContext(arm_assemblyParser.RegContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(arm_assemblyParser.COMMA)
            else:
                return self.getToken(arm_assemblyParser.COMMA, i)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_mla_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMla_instruction" ):
                listener.enterMla_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMla_instruction" ):
                listener.exitMla_instruction(self)




    def mla_instruction(self):

        localctx = arm_assemblyParser.Mla_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_mla_instruction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self.match(arm_assemblyParser.MLA)
            self.state = 72
            self.match(arm_assemblyParser.SPACE)
            self.state = 73
            self.reg()
            self.state = 74
            self.match(arm_assemblyParser.COMMA)
            self.state = 75
            self.reg()
            self.state = 76
            self.match(arm_assemblyParser.COMMA)
            self.state = 77
            self.reg()
            self.state = 78
            self.match(arm_assemblyParser.COMMA)
            self.state = 79
            self.reg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ls_instructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opcode = None # Token

        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(arm_assemblyParser.RegContext)
            else:
                return self.getTypedRuleContext(arm_assemblyParser.RegContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(arm_assemblyParser.COMMA)
            else:
                return self.getToken(arm_assemblyParser.COMMA, i)

        def LBRACKET(self):
            return self.getToken(arm_assemblyParser.LBRACKET, 0)

        def RBRACKET(self):
            return self.getToken(arm_assemblyParser.RBRACKET, 0)

        def LDR(self):
            return self.getToken(arm_assemblyParser.LDR, 0)

        def STR(self):
            return self.getToken(arm_assemblyParser.STR, 0)

        def operand2(self):
            return self.getTypedRuleContext(arm_assemblyParser.Operand2Context,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_ls_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLs_instruction" ):
                listener.enterLs_instruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLs_instruction" ):
                listener.exitLs_instruction(self)




    def ls_instruction(self):

        localctx = arm_assemblyParser.Ls_instructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ls_instruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            localctx.opcode = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==26 or _la==27):
                localctx.opcode = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 82
            self.match(arm_assemblyParser.SPACE)
            self.state = 83
            self.reg()
            self.state = 84
            self.match(arm_assemblyParser.COMMA)
            self.state = 85
            self.match(arm_assemblyParser.LBRACKET)
            self.state = 86
            self.reg()
            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 87
                self.match(arm_assemblyParser.COMMA)
                self.state = 88
                self.operand2()


            self.state = 91
            self.match(arm_assemblyParser.RBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_operandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(arm_assemblyParser.RegContext)
            else:
                return self.getTypedRuleContext(arm_assemblyParser.RegContext,i)


        def COMMA(self):
            return self.getToken(arm_assemblyParser.COMMA, 0)

        def immediate(self):
            return self.getTypedRuleContext(arm_assemblyParser.ImmediateContext,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_shift_operand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_operand" ):
                listener.enterShift_operand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_operand" ):
                listener.exitShift_operand(self)




    def shift_operand(self):

        localctx = arm_assemblyParser.Shift_operandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_shift_operand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.reg()
            self.state = 94
            self.match(arm_assemblyParser.COMMA)
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 95
                self.immediate()
                pass
            elif token in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]:
                self.state = 96
                self.reg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Operand2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def immediate_format(self):
            return self.getTypedRuleContext(arm_assemblyParser.Immediate_formatContext,0)


        def register_format(self):
            return self.getTypedRuleContext(arm_assemblyParser.Register_formatContext,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_operand2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperand2" ):
                listener.enterOperand2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperand2" ):
                listener.exitOperand2(self)




    def operand2(self):

        localctx = arm_assemblyParser.Operand2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_operand2)
        try:
            self.state = 101
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.immediate_format()
                pass
            elif token in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 100
                self.register_format()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Immediate_formatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def immediate(self):
            return self.getTypedRuleContext(arm_assemblyParser.ImmediateContext,0)


        def COMMA(self):
            return self.getToken(arm_assemblyParser.COMMA, 0)

        def HEX(self):
            return self.getToken(arm_assemblyParser.HEX, 0)

        def NUMBER(self):
            return self.getToken(arm_assemblyParser.NUMBER, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_immediate_format

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImmediate_format" ):
                listener.enterImmediate_format(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImmediate_format" ):
                listener.exitImmediate_format(self)




    def immediate_format(self):

        localctx = arm_assemblyParser.Immediate_formatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_immediate_format)
        self._la = 0 # Token type
        try:
            self.state = 108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 103
                self.immediate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.immediate()
                self.state = 105
                self.match(arm_assemblyParser.COMMA)
                self.state = 106
                _la = self._input.LA(1)
                if not(_la==35 or _la==36):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Register_formatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reg(self):
            return self.getTypedRuleContext(arm_assemblyParser.RegContext,0)


        def COMMA(self):
            return self.getToken(arm_assemblyParser.COMMA, 0)

        def shift_op(self):
            return self.getTypedRuleContext(arm_assemblyParser.Shift_opContext,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_register_format

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegister_format" ):
                listener.enterRegister_format(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegister_format" ):
                listener.exitRegister_format(self)




    def register_format(self):

        localctx = arm_assemblyParser.Register_formatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_register_format)
        try:
            self.state = 115
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.reg()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.reg()
                self.state = 112
                self.match(arm_assemblyParser.COMMA)
                self.state = 113
                self.shift_op()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_type(self):
            return self.getTypedRuleContext(arm_assemblyParser.Shift_typeContext,0)


        def SPACE(self):
            return self.getToken(arm_assemblyParser.SPACE, 0)

        def immediate_format(self):
            return self.getTypedRuleContext(arm_assemblyParser.Immediate_formatContext,0)


        def reg(self):
            return self.getTypedRuleContext(arm_assemblyParser.RegContext,0)


        def getRuleIndex(self):
            return arm_assemblyParser.RULE_shift_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_op" ):
                listener.enterShift_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_op" ):
                listener.exitShift_op(self)




    def shift_op(self):

        localctx = arm_assemblyParser.Shift_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_shift_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.shift_type()
            self.state = 118
            self.match(arm_assemblyParser.SPACE)
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 119
                self.immediate_format()
                pass
            elif token in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]:
                self.state = 120
                self.reg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSL(self):
            return self.getToken(arm_assemblyParser.LSL, 0)

        def LSR(self):
            return self.getToken(arm_assemblyParser.LSR, 0)

        def ASR(self):
            return self.getToken(arm_assemblyParser.ASR, 0)

        def ROR(self):
            return self.getToken(arm_assemblyParser.ROR, 0)

        def RRX(self):
            return self.getToken(arm_assemblyParser.RRX, 0)

        def getRuleIndex(self):
            return arm_assemblyParser.RULE_shift_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_type" ):
                listener.enterShift_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_type" ):
                listener.exitShift_type(self)




    def shift_type(self):

        localctx = arm_assemblyParser.Shift_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_shift_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8321499136) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





